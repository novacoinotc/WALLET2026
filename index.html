import TronWeb from "tronweb";
import solc from "solc";
import fs from "fs";

// ğŸ” Secrets (Replit â†’ Secrets)
const PRIVATE_KEY = process.env.PRIVATE_KEY;
const RPC_URL = process.env.RPC_URL || "https://api.trongrid.io"; // MAINNET

if (!PRIVATE_KEY) throw new Error("Falta PRIVATE_KEY en Secrets");

// TronWeb
const tronWeb = new TronWeb({ fullHost: RPC_URL, privateKey: PRIVATE_KEY });
const addr = tronWeb.address.fromPrivateKey(PRIVATE_KEY);
console.log("Mi address (MAINNET):", addr);

// --- Contrato FeeRouter ---
const source = `
pragma solidity ^0.8.20;
interface ITRC20 {
    function transfer(address to, uint256 value) external returns (bool);
    function transferFrom(address from, address to, uint256 value) external returns (bool);
    function approve(address spender, uint256 value) external returns (bool);
    function allowance(address owner, address spender) external view returns (uint256);
    function balanceOf(address owner) external view returns (uint256);
    function decimals() external view returns (uint8);
}
contract FeeRouter {
    event TransferWithFee(address indexed token, address indexed from, address indexed to,
        uint256 amount, address feeRecipient, uint256 feeAmount);
    function transferWithFee(address token, address to, uint256 amount, address feeRecipient,
        uint256 feeFixed, uint16 feeBps) external returns (bool) {
        require(to != address(0) && feeRecipient != address(0) && amount > 0, "invalid params");
        ITRC20 t = ITRC20(token);
        uint256 feeVariable = (amount * uint256(feeBps)) / 10_000;
        uint256 feeAmount = feeFixed + feeVariable;
        uint256 need = amount + feeAmount;
        require(t.allowance(msg.sender, address(this)) >= need, "allowance low");
        if (feeAmount > 0) require(t.transferFrom(msg.sender, feeRecipient, feeAmount));
        require(t.transferFrom(msg.sender, to, amount));
        emit TransferWithFee(token, msg.sender, to, amount, feeRecipient, feeAmount);
        return true;
    }
}
`;

// Compilar con solc
const input = {
  language: "Solidity",
  sources: { "FeeRouter.sol": { content: source } },
  settings: { outputSelection: { "*": { "*": ["abi", "evm.bytecode"] } } },
};
const output = JSON.parse(solc.compile(JSON.stringify(input)));
if (output.errors) {
  const fatal = output.errors.find((e) => e.severity === "error");
  if (fatal) throw new Error(fatal.formattedMessage);
}
const artifact = output.contracts["FeeRouter.sol"]["FeeRouter"];
const abi = artifact.abi;
const bytecode = "0x" + artifact.evm.bytecode.object;

// Guardar ABI (referencia)
fs.writeFileSync("FeeRouter_ABI.json", JSON.stringify(abi, null, 2));
console.log("ABI guardado en FeeRouter_ABI.json âœ…");

// Deploy
(async () => {
  try {
    console.log("ğŸ”¹ Preparando recursos (freeze 300 TRX â†’ ENERGY)...");
    try {
      // 300 TRX = 300_000_000 SUN
      await tronWeb.trx.freezeBalanceV2(300_000_000, "ENERGY");
      console.log("âœ… ENERGY asignada (freeze ok)");
    } catch (e) {
      console.log("âš ï¸ No se pudo hacer freeze (continuo si ya tienes recursos):", e?.message || e);
    }

    console.log("ğŸ”¹ Desplegando FeeRouter en MAINNET...");
    const instance = await tronWeb.contract().new({
      abi,
      bytecode,
      feeLimit: 100_000_000, // 100 TRX lÃ­mite
    });

    console.log("âœ… Deploy ok");
    console.log("ğŸ“„ DirecciÃ³n del contrato (hex):", instance.address);
    console.log("ğŸ“„ DirecciÃ³n del contrato (T...):", tronWeb.address.fromHex(instance.address));
  } catch (e) {
    console.error("âŒ Error en deploy:", e);
  }
})();
